import{useRef as e,useEffect as r,useReducer as t,useState as n}from"react";function a(){return(a=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}const o=async(e,r,t)=>r&&t?t.encrypt(e,r):Promise.resolve(e),u=async(e,r,t)=>r&&t?t.decrypt(e,r):Promise.resolve(e),s=(e,r=100)=>{let t,n=[];return a=>(n.push(a),t||(t=setTimeout(()=>{let r=n.reduce((e,{id:r,data:t})=>(e[r]=t,e),{});e(r),n=[],t=null},r)),()=>{clearTimeout(t),n=[],t=null})},c=(e,{data:r,type:t})=>{switch(t){case"add":return a({},e,r);case"update":return a({},e,{[r.nodeID]:r});case"remove":return delete e[r],a({},e);default:throw new Error}},i=()=>{const t=e(!1);return r(()=>(t.current=!0,()=>t.current=!1),[]),t},l=(e,r)=>{const[n,a]=t(e,r),o=i();return[n,function(e){o.current&&a(e)}]},p=(e,r)=>{const[t]=n(e({peers:r}));return[t]},d=e=>{const[r,t]=n(null);return r||t(e.user()),[r]},w=(e,t,a=!0)=>{const[o]=d(e),[u,s]=n(!1);return e.on("auth",()=>{s(!0)}),r(()=>{o&&!o.is&&t&&a&&o.auth(t)},[a,o,t]),[o,u]},y=(e,r)=>{const[t,a]=n(r);return t||async function(){const r=await e.pair();a(r)}(),[t,a]},f=(t,a={appKeys:"",sea:null,interval:100,useOpen:!1})=>{const{appKeys:p,sea:d,interval:w=100,useOpen:y=!1}=a,[f]=n(t),[m,h]=l(c,{}),v=e(null),P=i();return r(()=>{const e=[];if(P.current){const r=s(e=>{h({type:"add",data:e})},w),t=async(t,n,a,o)=>{let s=await u(t,p,d);Object.keys(s).forEach(t=>{let n=r({id:t,data:s[t]});e.push(n)}),v.current||(v.current=o)};if(y){if(!f.open)throw new Error("Please include gun/lib/open.");f.open(t)}else f.on(t)}return()=>{v.current&&v.current.off(),e.length&&e.forEach(e=>e())}},[]),{fields:m,put:async e=>{let r=await o(e,p,d);await new Promise((e,t)=>f.put(r,r=>r.err?t(r.err):e()))},remove:async e=>{await new Promise((e,r)=>f.put(null,t=>t.err?r(t.err):e())),h({type:"remove",data:e})}}},m=(t,p={appKeys:"",sea:null,interval:100,useOpen:!1})=>{const{appKeys:d,sea:w,interval:y=100,useOpen:f}=p,[m]=n(t),[h,v]=l(c,{}),P=e(null),g=i();return r(()=>{const e=[];if(g.current){const r=s(e=>{v({type:"add",data:e})},y),t=async(t,n,o,s)=>{let c=await u(t,d,w);if(c){let t=r({id:n,data:a({},c,{nodeID:n})});e.push(t)}P.current||(P.current=s)};if(f){if(!m.open)throw new Error("Please include gun/lib/open.");m.map().open(t)}else m.map().on(t)}return()=>{P.current&&P.current.off(),e.length&&e.forEach(e=>e())}},[]),{collection:h,addToSet:async(e,r)=>{let t=await o(e,d,w);r?await new Promise((e,n)=>m.get(r).put(t,r=>r.err?n(r.err):e())):await new Promise((e,r)=>m.set(t,t=>t.err?r(t.err):e()))},updateInSet:async(e,r)=>{let t=await o(r,d,w);await new Promise((r,n)=>m.get(e).put(t,e=>e.err?n(e.err):r())),v({type:"update",data:a({nodeID:e},r)})},removeFromSet:async e=>{await new Promise((r,t)=>m.get(e).put(null,e=>e.err?t(e.err):r()))}}};export{s as debouncedUpdates,u as decryptData,o as encryptData,c as reducer,p as useGun,m as useGunCollectionState,w as useGunKeyAuth,y as useGunKeys,d as useGunNamespace,f as useGunState,i as useIsMounted,l as useSafeReducer};
//# sourceMappingURL=index.modern.js.map
